const { User } = require("../Models/user");
const { CVE } = require("../Models/cve");
const { CPE } = require("../Models/cpe");
const axios = require("axios");
require("dotenv").config();
const { sendEmail } = require("./sendEmail.js");

findNewCVEs = async (givenDate) => {
  const users = await User.find({}).select("-password");

  const allCpes = await CPE.find({})
    .populate("cves")
    .populate("newCVEs")
    .populate("users");

  let userEmailContents = {};
  for (let j = 0; j < users.length; j++) {
    userEmailContents[users[j].username] = [];
  }

  let date = makeStartAndEndDate();
  if (givenDate) date = givenDate;

  for (let i = 0; i < allCpes.length; i++) {
    const currentCPE = allCpes[i];
    const requestString = `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${currentCPE.cpeName}&pubStartDate=${date.startYear}-${date.startMonth}-${date.startDate}T00:00:00.000&pubEndDate=${date.endYear}-${date.endMonth}-${date.endDate}T00:00:00.000`;
    console.log(requestString);

    try {
      const freshNewCVEs = [];

      const response = await axios.get(requestString, {
        headers: { apiKey: "fbdba56c-61a3-4734-825b-b7763d4db31a" },
      });
      console.log(
        "vulnerabilities length: " + response.data.vulnerabilities.length
      );

      for (
        let index = 0;
        index < response.data.vulnerabilities.length;
        index++
      ) {
        const sameCVEInCVEs = currentCPE.cves.filter(
          (c) => c.cveCode === response.data.vulnerabilities[index].cve.id
        );

        const sameCVEInNewCVEs = currentCPE.newCVEs.filter(
          (c) => c.cveCode === response.data.vulnerabilities[index].cve.id
        );

        const currentCVE = await CVE.findOne({
          cveCode: response.data.vulnerabilities[index].cve.id,
        });

        if (currentCVE) {
          if (sameCVEInCVEs.length === 0) currentCPE.cves.push(currentCVE);
          if (sameCVEInNewCVEs.length === 0) {
            freshNewCVEs.push(currentCVE);

            //add this program to every user Emailcontent (every user on this program)
            for (let j = 0; j < currentCPE.users.length; j++) {
              const username = currentCPE.users[j].username;

              if (!userEmailContents[username].includes(currentCPE.title))
                userEmailContents[username].push(currentCPE.title);
            }
          }

          if (sameCVEInNewCVEs.length === 1) {
            freshNewCVEs.push(currentCVE);
          }
          continue;
        }

        var keyNames = Object.keys(
          response.data.vulnerabilities[index].cve.metrics
        );
        let format = "";

        if (keyNames.includes("cvssMetricV31")) format = "cvssMetricV31";
        else if (keyNames.includes("cvssMetricV30")) format = "cvssMetricV30";
        else if (keyNames.includes("cvssMetricV2")) format = "cvssMetricV2";

        const cve = new CVE({
          cveCode: response.data.vulnerabilities[index].cve.id,
          text: response.data.vulnerabilities[index].cve.descriptions[0].value,
          lastModified: response.data.vulnerabilities[index].cve.lastModified,
          exploitabilityScore:
            response.data.vulnerabilities[index].cve.metrics[format][0]
              .exploitabilityScore,
          impactScore:
            response.data.vulnerabilities[index].cve.metrics[format][0]
              .impactScore,
          format: format,
          source:
            response.data.vulnerabilities[index].cve.metrics[format][0].source,
          baseScore:
            response.data.vulnerabilities[index].cve.metrics[format][0].cvssData
              .baseScore,
        });

        currentCPE.cves.push(cve);
        freshNewCVEs.push(cve);
        //add this program to every user Emailcontent (every user on this program)
        for (let j = 0; j < currentCPE.users.length; j++) {
          const username = currentCPE.users[j].username;
          if (!userEmailContents[username].includes(currentCPE.title))
            userEmailContents[username].push(currentCPE.title);
        }
        await cve.save();
      }

      currentCPE.newCVEs = freshNewCVEs;
      await currentCPE.save();
    } catch (e) {
      if (e.response && e.response.status == 400)
        return res.status(400).send({
          error: "فرمت برنامه مورد نظر صحیح نیست.",
          type: "wrongCPE",
        });

      if (e.response && e.response.status == 503)
        return res.status(503).send({
          error: "سرویس موقتا از دسترس خارج شده.",
          type: "unavalableService",
        });
    }
  }

  for (let j = 0; j < users.length; j++) {
    if (userEmailContents[users[j].username].length > 0)
      sendEmail(
        users[j].username,
        userEmailContents[users[j].username],
        users[j].email
      );
  }
  console.log("DONE");
};

makeStartAndEndDate = () => {
  var d = new Date();

  var endYear = d.getFullYear();
  var endMonth = d.getUTCMonth();
  endMonth++;

  if (endMonth < 10) endMonth = "0" + endMonth;
  var endDate = d.getDate();
  if (endDate < 10) endDate = "0" + endDate;

  var h = new Date(new Date().getTime() - 3 * 30 * 24 * 60 * 60 * 1000);

  var startYear = h.getFullYear();
  var startMonth = h.getMonth();
  if (startMonth < 10) startMonth = "0" + startMonth;
  var startDate = h.getDate();
  if (startDate < 10) startDate = "0" + startDate;

  return {
    startDate: startDate,
    startMonth: startMonth,
    startYear: startYear,
    endDate: endDate,
    endMonth: endMonth,
    endYear: endYear,
  };
};

module.exports = {
  findNewCVEs,
  makeStartAndEndDate,
};
