const mongoose = require("mongoose");
const users = require("./Routes/users");
const my_cpes = require("./Routes/my-cpes");
const cpes = require("./Routes/cpes");
const express = require("express");
const app = express();
const cors = require("cors");
const cron = require("node-cron");
const Joi = require("joi");
const { User } = require("./models/user");
const { CVE } = require("./models/cve");
const { CPE } = require("./models/cpe");
const router = express.Router();
const auth = require("./middleware/auth.js");
const axios = require("axios");
var ObjectId = mongoose.Types.ObjectId;

app.use(cors());
app.use(express.json());

mongoose
  .connect("mongodb://127.0.0.1:27017/CVE")
  .then(() => console.log("connected to DB"))
  .catch((err) => console.log("can not connect to DB"));

app.use("/users", users);
app.use("/my-cpes", my_cpes);
app.use("/cpes", cpes);

app.listen(3001, () => console.log("listening on port 3001"));

cron.schedule("0 0 * * 0", () => {
  findNewCVEs();
});

const findNewCVEs = async () => {
  const users = await User.find().select("-password").populate("userPrograms");

  for (let u = 0; u < users.length; u++) {
    const user = users[u];
    var d = new Date();
    var endYear = d.getFullYear();
    var endMonth = d.getMonth();
    if (endMonth < 10) endMonth = "0" + endMonth;
    var endDate = d.getDate();
    if (endDate < 10) endDate = "0" + endDate;

    var h = new Date(new Date().getTime() - 3 * 30 * 24 * 60 * 60 * 1000);
    var startYear = h.getFullYear();
    var startMonth = h.getMonth();
    if (startMonth < 10) startMonth = "0" + startMonth;
    var startDate = h.getDate();
    if (startDate < 10) startDate = "0" + startDate;

    for (let i = 0; i < user.userPrograms.length; i++) {
      try {
        response = await axios.get(
          `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${user.userPrograms[i].cpeName}&pubStartDate=${startYear}-${startMonth}-${startDate}T00:00:00.000&pubEndDate=${endYear}-${endMonth}-${endDate}T00:00:00.000`,
          {
            headers: { apiKey: "fbdba56c-61a3-4734-825b-b7763d4db31a" },
          }
        );

        console.log(response.data.vulnerabilities.length);

        const currentCPE = await CPE.findOne({
          cpeName: user.userPrograms[i].cpeName,
        })
          .populate("cves")
          .populate("newCVEs");

        for (
          let index = 0;
          index < response.data.vulnerabilities.length;
          index++
        ) {
          const sameCVEInCVEs = currentCPE.cves.filter(
            (c) => c.cveCode === response.data.vulnerabilities[index].cve.id
          );

          const sameCVEInNewCVEs = currentCPE.newCVEs.filter(
            (c) => c.cveCode === response.data.vulnerabilities[index].cve.id
          );

          const currentCVE = await CVE.findOne({
            cveCode: response.data.vulnerabilities[index].cve.id,
          });

          if (sameCVEInCVEs.length === 1) {
            if (sameCVEInNewCVEs.length === 0)
              currentCPE.newCVEs.push(currentCVE);
            continue;
          }

          if (currentCVE !== null) {
            if (sameCVEInCVEs.length === 0) currentCPE.cves.push(currentCVE);
            if (sameCVEInNewCVEs.length === 0)
              currentCPE.newCVEs.push(currentCVE);
            continue;
          }

          var keyNames = Object.keys(
            response.data.vulnerabilities[index].cve.metrics
          );
          let format = "";

          if (keyNames.includes("cvssMetricV31")) format = "cvssMetricV31";
          else if (keyNames.includes("cvssMetricV30")) format = "cvssMetricV30";
          else if (keyNames.includes("cvssMetricV2")) format = "cvssMetricV2";

          const cve = new CVE({
            cveCode: response.data.vulnerabilities[index].cve.id,
            text:
              response.data.vulnerabilities[index].cve.descriptions[0].value,
            lastModified: response.data.vulnerabilities[index].cve.lastModified,
            exploitabilityScore:
              response.data.vulnerabilities[index].cve.metrics[format][0]
                .exploitabilityScore,
            impactScore:
              response.data.vulnerabilities[index].cve.metrics[format][0]
                .impactScore,
            format: format,
            source:
              response.data.vulnerabilities[index].cve.metrics[format][0]
                .source,
            baseScore:
              response.data.vulnerabilities[index].cve.metrics[format][0]
                .cvssData.baseScore,
          });

          currentCPE.cves.push(cve);
          currentCPE.newCVEs.push(cve);
          await cve.save();
          await currentCPE.save();
        }
        await currentCPE.save();
      } catch (e) {
        if (e.response && e.response.status == 400)
          return res.status(400).send({
            error: "فرمت برنامه مورد نظر صحیح نیست.",
            type: "wrongCPE",
          });

        if (e.response && e.response.status == 503)
          return res.status(503).send({
            error: "سرویس موقتا از دسترس خارج شده.",
            type: "unavalableService",
          });
      }
    }
  }
  console.log("done");
};
