const Joi = require("joi");
const { User } = require("../Models/user");
const { CVE } = require("../Models/cve");
const { CPE } = require("../Models/cpe");
const mongoose = require("mongoose");
const express = require("express");
const router = express.Router();
const auth = require("../middleware/auth.js");
const axios = require("axios");
var ObjectId = mongoose.Types.ObjectId;
const { findNewCVEs, sendEmail } = require("../func");

/*router.post("/", auth, async (req, res) => {
  const user = await User.findById(req.user._id).select("-password");
  let programsClone = [...user.userPrograms];
  const programObjectId = new ObjectId(req.body.id);

  programsClone = programsClone.filter(
    (p) => p.program.toString() === req.body.id
  );
  if (programsClone.length > 0)
    return res.status(401).send({ error: "This program is already added" });


  //getting new CVEs for this choosen program


  const payload = { program: programObjectId, cvesList: [] };
  user.userPrograms.push(payload);
  user.save();
  res.send(user);
});*/

router.get("/", auth, async (req, res) => {
  const user = await User.findById(req.user._id)
    .select("-password")
    .populate("userPrograms");
  res.send(user.userPrograms);
});

router.get("/:cpeId", auth, async (req, res) => {
  const user = await User.findById(req.user._id)
    .select("-password")
    .populate("userPrograms");

  let cpe = undefined;
  for (let i = 0; i < user.userPrograms.length; i++) {
    if (user.userPrograms[i].cpeId === req.params.cpeId) {
      cpe = user.userPrograms[i];
      break;
    }
  }

  if (!cpe)
    return res.status(404).send({
      error: "برنامه مورد نظر پیدا نشد.",
      type: "cpeNotFound",
    });
  res.send(cpe);
});

router.get("/released-cves/smart", auth, async (req, res) => {
  await findNewCVEs();
  res.send({ message: "ناامنی‌های جدید بررسی شد." });
});

router.get("/released-cves/new", auth, async (req, res) => {
  const user = await User.findById(req.user._id)
    .select("-password")
    .populate("userPrograms");

  for (let i = 0; i < user.userPrograms.length; i++) {
    try {
      response = await axios.get(
        `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${user.userPrograms[i].cpeName}`,
        {
          headers: { apiKey: "fbdba56c-61a3-4734-825b-b7763d4db31a" },
        }
      );
      const currentCPE = await CPE.findOne({
        cpeName: user.userPrograms[i].cpeName,
      }).populate("cves");
      if (
        currentCPE.cpeName !=
        "cpe:2.3:a:microsoft:powerpoint:2000:*:*:*:*:*:*:*"
      )
        continue;
      console.log(currentCPE.cpeName);
      for (
        let index = 0;
        index < response.data.vulnerabilities.length;
        index++
      ) {
        const result = currentCPE.cves.filter(
          (c) => c.cveCode === response.data.vulnerabilities[index].cve.id
        );

        if (result.length === 1) {
          continue;
        }

        console.log(response.data.vulnerabilities[index].cve.id);
        const currentCVE = await CVE.findOne({
          cveCode: response.data.vulnerabilities[index].cve.id,
        });

        if (currentCVE !== null) {
          currentCPE.cves.push(currentCVE);
          currentCPE.newCVEs.push(currentCVE);
          continue;
        }

        var keyNames = Object.keys(
          response.data.vulnerabilities[index].cve.metrics
        );
        let format = "";

        if (keyNames.includes("cvssMetricV31")) format = "cvssMetricV31";
        else if (keyNames.includes("cvssMetricV30")) format = "cvssMetricV30";
        else if (keyNames.includes("cvssMetricV2")) format = "cvssMetricV2";

        const cve = new CVE({
          cveCode: response.data.vulnerabilities[index].cve.id,
          text: response.data.vulnerabilities[index].cve.descriptions[0].value,
          lastModified: response.data.vulnerabilities[index].cve.lastModified,
          exploitabilityScore:
            response.data.vulnerabilities[index].cve.metrics[format][0]
              .exploitabilityScore,
          impactScore:
            response.data.vulnerabilities[index].cve.metrics[format][0]
              .impactScore,
          format: format,
          source:
            response.data.vulnerabilities[index].cve.metrics[format][0].source,
          baseScore:
            response.data.vulnerabilities[index].cve.metrics[format][0].cvssData
              .baseScore,
        });

        currentCPE.cves.push(cve);
        currentCPE.newCVEs.push(cve);
        await cve.save();
        await currentCPE.save();
      }
    } catch (e) {
      if (e.response && e.response.status == 400)
        return res.status(400).send({
          error: "فرمت برنامه مورد نظر صحیح نیست.",
          type: "wrongCPE",
        });

      if (e.response && e.response.status == 503)
        return res.status(503).send({
          error: "سرویس موقتا از دسترس خارج شده.",
          type: "unavalableService",
        });
    }
  }
  res.send({ message: "ناامنی های جدید ذخیره شد." });
});

router.get("/:cpeId/new-cves", auth, async (req, res) => {
  let cpe = undefined;
  cpe = await CPE.findOne({ cpeId: req.params.cpeId }).populate("newCVEs");

  if (!cpe)
    return res.status(404).send({
      error: "برنامه مورد نظر پیدا نشد.",
      type: "cpeNotFound",
    });

  res.send({ newCVEs: cpe.newCVEs, cpeTitle: cpe.title });
});

router.get("/:cpeId/cves", auth, async (req, res) => {
  const cpe = await CPE.findOne({ cpeId: req.params.cpeId }).populate("cves");
  if (!cpe)
    return res.status(404).send({
      error: "برنامه مورد نظر پیدا نشد.",
      type: "cpeNotFound",
    });
  res.send({ cves: cpe.cves, cpeTitle: cpe.title });
});

router.get("/:cpeId/cves/:cveCode", auth, async (req, res) => {
  const cpe = await CPE.findOne({ cpeId: req.params.cpeId }).populate("cves");
  const cve = await CVE.findOne({ cveCode: req.params.cveCode });

  if (!cpe)
    return res.status(404).send({
      error: "برنامه مورد نظر پیدا نشد.",
      type: "cpeNotFound",
    });

  const findedCves = cpe.cves.filter((c) => c.cveCode === req.params.cveCode);

  if (findedCves.length != 1 || !cve)
    return res.status(404).send({
      error: "ناامنی مورد نظر پیدا نشد.",
      type: "cveNotFound",
    });

  res.send(cve);
});

router.post("/", auth, async (req, res) => {
  const user = await User.findById(req.user._id).select("-password");
  let programsClone = [...user.userPrograms];

  let currentProgram = await CPE.findOne({ cpeName: req.body.cpeName });

  if (!currentProgram) {
    console.log(req.body);
    let response = undefined;
    let totalResult = 2001;

    const newProgram = new CPE({
      cpeName: req.body.cpeName,
      cpeId: req.body.cpeId,
      title: req.body.title,
      cves: [],
    });
    for (let pageIndex = 0; pageIndex <= 1; pageIndex++) {
      try {
        response = await axios.get(
          `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${
            req.body.cpeName
          }&startIndex=${pageIndex * 2000}`,
          {
            headers: { apiKey: "fbdba56c-61a3-4734-825b-b7763d4db31a" },
          }
        );
        totalResult = response.data.totalResults;

        for (
          let index = 0;
          index < response.data.vulnerabilities.length;
          index++
        ) {
          const currentCVE = await CVE.findOne({
            cveCode: response.data.vulnerabilities[index].cve.id,
          });

          if (currentCVE !== null) {
            newProgram.cves.push(currentCVE);
            continue;
          }

          var keyNames = Object.keys(
            response.data.vulnerabilities[index].cve.metrics
          );
          let format = "";

          if (keyNames.includes("cvssMetricV31")) format = "cvssMetricV31";
          else if (keyNames.includes("cvssMetricV30")) format = "cvssMetricV30";
          else if (keyNames.includes("cvssMetricV2")) format = "cvssMetricV2";

          const cve = new CVE({
            cveCode: response.data.vulnerabilities[index].cve.id,
            text:
              response.data.vulnerabilities[index].cve.descriptions[0].value,
            lastModified: response.data.vulnerabilities[index].cve.lastModified,
            exploitabilityScore:
              response.data.vulnerabilities[index].cve.metrics[format][0]
                .exploitabilityScore,
            impactScore:
              response.data.vulnerabilities[index].cve.metrics[format][0]
                .impactScore,
            format: format,
            source:
              response.data.vulnerabilities[index].cve.metrics[format][0]
                .source,
            baseScore:
              response.data.vulnerabilities[index].cve.metrics[format][0]
                .cvssData.baseScore,
          });

          newProgram.cves.push(cve);
          await cve.save();
        }

        await newProgram.save();
        currentProgram = newProgram;
      } catch (e) {
        if (e.response && e.response.status == 400)
          return res.status(400).send({
            error:
              "فرمت برنامه مورد نظر صحیح نیست. جستجوی دستی را امتحان کنید.",
            type: "wrongCPE",
          });

        if (e.response && e.response.status == 503)
          return res.status(503).send({
            error: "سرویس موقتا از دسترس خارج شده.",
            type: "unavalableService",
          });
      }
    }
  }

  if (programsClone.length > 0)
    programsClone = programsClone.filter(
      (p) => p.toString() === currentProgram._id.toString()
    );
  if (programsClone.length > 0)
    return res
      .status(400)
      .send({ error: "این برنامه قبلا اضافه شده است", type: "duplicateCPE" });

  if (!currentProgram)
    return res
      .status(400)
      .send({ error: "چنین برنامه‌ای یافت نشد.", type: "wrongInputFormat" });
  user.userPrograms.push(currentProgram._id);
  user.save();
  res.send(user);
});

router.delete("/:cpeId", auth, async (req, res) => {
  const user = await User.findById(req.user._id)
    .select("-password")
    .populate("userPrograms");

  let programsClone = [...user.userPrograms];
  programsClone = programsClone.filter((p) => !(p.cpeId === req.params.cpeId));

  user.userPrograms = programsClone;

  user.save();
  res.send({ message: "deleted successfully" });
});

module.exports = router;
